import os
import subprocess
import sys

import requests
from dotenv import load_dotenv  # To load variables from .env file

# Load environment variables from a .env file at the start of the script
load_dotenv()

class VulnerabilityFixer:
    """
    Parses a Snyk report, uses Google's Gemini API to generate an OpenRewrite recipe,
    and applies the fix to a Maven project.
    """
    def __init__(self, model='gemini-2.0-flash'):
        """
        Initializes the VulnerabilityFixer class.

        Args:
            model (str): The name of the Gemini model to use via the API.
        """
        self.project_root = os.getcwd()
        self.report_path = os.path.join(self.project_root, '.dev-aegis', 'analyser', 'snyk-report.md')
        self.recipe_path = os.path.join(self.project_root, 'rewrite.yml')

        # LLM Interaction attributes
        self.model = model
        self.api_key = os.environ.get('GEMINI_API_KEY')
        if not self.api_key:
            print("ERROR: Gemini API key not found. Please set the GEMINI_API_KEY environment variable or add it to a .env file.", file=sys.stderr)

        # Use v1beta endpoint which is common for new models and features
        self.api_url = f"https://generativelanguage.googleapis.com/v1beta/models/{self.model}:generateContent?key={self.api_key}"

    def _get_llm_response(self, prompt):
        """Sends a prompt to the Gemini API and gets a response."""
        if not self.api_key:
            print("ERROR: Gemini API key not set. Cannot make API call.", file=sys.stderr)
            return None

        print(f"INFO: Sending prompt to model '{self.model}' via Gemini API...")

        # Gemini uses a 'contents' structure for prompts. System instructions can be included.
        payload = {
            "contents": [{
                "parts": [{"text": prompt}]
            }],
            "systemInstruction": {
                "parts": [{"text": "You are an expert in Java project refactoring using OpenRewrite. Only output raw YAML."}]
            }
        }

        try:
            response = requests.post(self.api_url, json=payload, timeout=300)
            response.raise_for_status()
            result = response.json()

            # Extract the generated text from the Gemini API response structure
            candidate = result.get('candidates', [{}])[0]
            if 'content' in candidate and 'parts' in candidate['content']:
                 return candidate['content']['parts'][0].get('text', 'Error: No text in Gemini API response part.')
            else:
                 print(f"ERROR: Received an unexpected response from Gemini API: {result}", file=sys.stderr)
                 return "Error: Invalid response structure from API."


        except requests.RequestException as e:
            print(f"ERROR: An error occurred while communicating with the Gemini API: {e}", file=sys.stderr)
            if e.response is not None:
                print(f"Response body: {e.response.text}", file=sys.stderr)
            return None

    def parse_snyk_report(self):
        """
        Parses the snyk-report.md file to find vulnerabilities with fixed versions.

        Returns:
            A list of dictionaries, each containing 'package', 'old_version',
            and 'fixed_in_version' for a vulnerability.
        """
        if not os.path.exists(self.report_path):
            print(f"ERROR: Snyk report not found at '{self.report_path}'", file=sys.stderr)
            return []

        print(f"INFO: Parsing Snyk report from '{self.report_path}'...")
        vulnerabilities = []
        with open(self.report_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        table_started = False
        for line in lines:
            if "| Package |" in line:
                table_started = True
                continue
            if not table_started or "|---|" in line:
                continue

            parts = [p.strip() for p in line.split('|') if p.strip()]
            if len(parts) >= 4:
                package, _, old_version, fixed_in_version, introduced_through = parts[0], parts[1], parts[2], parts[3], parts[4]
                if fixed_in_version.lower() != 'na':
                    vulnerabilities.append({
                        "package": package,
                        "old_version": old_version,
                        "fixed_in_version": fixed_in_version,
                        "introduced_through" : introduced_through
                    })
        print(f"INFO: Found {len(vulnerabilities)} vulnerabilities with available fixes in the report.")
        return vulnerabilities

    def generate_rewrite_recipe(self, vulnerabilities):
        """
        Generates a prompt and uses the LLM to create a composite OpenRewrite recipe.
        """
        if not vulnerabilities:
            return None

        prompt_header = (
            "Create a single OpenRewrite YAML configuration file. "
            "Do not add any explanation or markdown formatting.\n"
            "The file must start with `---`.\n\n"
            "Each entry in the list must be a fully configured `org.openrewrite.maven.UpgradeDependencyVersion` recipe with the `groupId`, `artifactId`, and `newVersion`(Only one version should be present, its preferred if the closest version is picked) for one of the dependencies listed below. If the dependency are transient dependencies the parent dependency declared in the pom should be updated. For this purpose use the Dependency traversal which also includes the actual repo name as the first level skip that. Incase the parent dependency is has no updates which would pull the latest version vulnerable dependency to fix it. we need to exclude that dependency from the parent using the recipe`org.openrewrite.maven.ExcludeDependency` with group id and artifact id from the info below. And it should add the dependency directly into the pom with the fixed in version mentioned below using the `org.openrewrite.maven.AddDependency` recipe with the group id, artifact id and the fixed in version mentioned below\n\n"
            "The name of the recipe should be org.devaegis.UpgradeVulnerableDependencies.\n\n"
            "Here are the dependencies to upgrade:\n"
        )

        dependency_list_str = ""
        for i, vuln in enumerate(vulnerabilities):
            group_id, artifact_id = vuln['package'].rsplit(':', 1)
            dependency_list_str += (
                f"{i+1}. GroupID: '{group_id}', ArtifactID: '{artifact_id}', "
                f"New Version: '{vuln['fixed_in_version']}', "
                f"Dependency traversal : '{vuln['introduced_through']}'\n"
            )

        full_prompt = prompt_header + dependency_list_str
        print(full_prompt)
        recipe_yaml = self._get_llm_response(full_prompt)

        # The API might still wrap the response in markdown, so we clean it up.
        if recipe_yaml and recipe_yaml.strip().startswith("```yaml"):
            recipe_yaml = recipe_yaml.strip()
            recipe_yaml = recipe_yaml.replace("```yaml\n", "").replace("\n```", "")

        return recipe_yaml

    def apply_fixes(self, recipe_yaml):
        """
        Saves the recipe and runs Maven OpenRewrite plugin to apply it.
        """
        # if not recipe_yaml or "activeRecipes" not in recipe_yaml:
        #     print("ERROR: LLM did not return a valid OpenRewrite configuration. Aborting.", file=sys.stderr)
        #     print(f"Received response:\n{recipe_yaml}")
        #     return

        print("--- Generated OpenRewrite Recipe ---")
        print(recipe_yaml)
        print("------------------------------------")

        print(f"INFO: Saving generated recipe to '{self.recipe_path}'...")
        os.makedirs(os.path.dirname(self.recipe_path), exist_ok=True)
        with open(self.recipe_path, 'w', encoding='utf-8') as f:
            f.write(recipe_yaml)

        print("INFO: Applying OpenRewrite recipe using Maven... (This may take a while)")
        command = [
            'mvn',
            'org.openrewrite.maven:rewrite-maven-plugin:run',
            f'-Drewrite.activeRecipes=org.devaegis.UpgradeVulnerableDependencies'
        ]

        try:
            result = subprocess.run(command, cwd=self.project_root, capture_output=True, text=True, check=True)
            print("INFO: Maven OpenRewrite plugin executed successfully.")
            # Always print stdout to see what OpenRewrite did
            print("STDOUT:\n", result.stdout)
        except FileNotFoundError:
            print("ERROR: 'mvn' command not found. Please ensure Maven is installed and in your PATH.", file=sys.stderr)
        except subprocess.CalledProcessError as e:
            print("ERROR: Maven OpenRewrite plugin failed to execute.", file=sys.stderr)
            print("STDERR:\n", e.stderr)
            print("STDOUT:\n", e.stdout)

    def run(self):
        """Orchestrates the entire vulnerability fixing process."""
        vulnerabilities = self.parse_snyk_report()
        if not vulnerabilities:
            print("INFO: No actionable vulnerabilities found in the report. Exiting.")
            return

        recipe = self.generate_rewrite_recipe(vulnerabilities)
        if recipe:
            self.apply_fixes(recipe)
        else:
            print("ERROR: Failed to generate a recipe. No fixes will be applied.", file=sys.stderr)


def main():
    """Main function to initialize and run the vulnerability fixer."""
    print("--- Automated Vulnerability Fixer ---")
    fixer = VulnerabilityFixer()
    fixer.run()
    print("\n--- Process Completed ---")

if __name__ == "__main__":
    main()
