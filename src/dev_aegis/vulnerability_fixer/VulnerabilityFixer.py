import sys
import os
import subprocess
import requests
import json
from dotenv import load_dotenv  # To load variables from .env file

# Load environment variables from a .env file at the start of the script
load_dotenv()

class VulnerabilityFixer:
    """
    Parses a Snyk report, uses Google's Gemini API to generate an OpenRewrite recipe,
    and applies the fix to a Maven project.
    """
    def __init__(self, model='gemini-1.5-flash-latest'):
        """
        Initializes the VulnerabilityFixer class.

        Args:
            model (str): The name of the Gemini model to use via the API.
        """
        self.project_root = os.getcwd()
        self.report_path = os.path.join(self.project_root, '.dev-aegis', 'analyser', 'snyk-report.md')
        self.recipe_path = os.path.join(self.project_root, 'openrewrite-recipe.yml')

        # LLM Interaction attributes
        self.model = model
        self.api_key = os.environ.get('GEMINI_API_KEY')
        if not self.api_key:
            print("ERROR: Gemini API key not found. Please set the GEMINI_API_KEY environment variable or add it to a .env file.", file=sys.stderr)

        # Use v1beta endpoint which is common for new models and features
        self.api_url = f"https://generativelanguage.googleapis.com/v1beta/models/{self.model}:generateContent?key={self.api_key}"

    def _get_llm_response(self, prompt):
        """Sends a prompt to the Gemini API and gets a response."""
        if not self.api_key:
            print("ERROR: Gemini API key not set. Cannot make API call.", file=sys.stderr)
            return None

        print(f"INFO: Sending prompt to model '{self.model}' via Gemini API...")

        # Gemini uses a 'contents' structure for prompts. System instructions can be included.
        payload = {
            "contents": [{
                "parts": [{"text": prompt}]
            }],
            "systemInstruction": {
                "parts": [{"text": "You are an expert in Java project refactoring using OpenRewrite. Only output raw YAML."}]
            }
        }

        try:
            response = requests.post(self.api_url, json=payload, timeout=300)
            response.raise_for_status()
            result = response.json()

            # Extract the generated text from the Gemini API response structure
            candidate = result.get('candidates', [{}])[0]
            if 'content' in candidate and 'parts' in candidate['content']:
                 return candidate['content']['parts'][0].get('text', 'Error: No text in Gemini API response part.')
            else:
                 print(f"ERROR: Received an unexpected response from Gemini API: {result}", file=sys.stderr)
                 return "Error: Invalid response structure from API."


        except requests.RequestException as e:
            print(f"ERROR: An error occurred while communicating with the Gemini API: {e}", file=sys.stderr)
            if e.response is not None:
                print(f"Response body: {e.response.text}", file=sys.stderr)
            return None

    def parse_snyk_report(self):
        """
        Parses the snyk-report.md file to find vulnerabilities with fixed versions.

        Returns:
            A list of dictionaries, each containing 'package', 'old_version',
            and 'fixed_in_version' for a vulnerability.
        """
        if not os.path.exists(self.report_path):
            print(f"ERROR: Snyk report not found at '{self.report_path}'", file=sys.stderr)
            return []

        print(f"INFO: Parsing Snyk report from '{self.report_path}'...")
        vulnerabilities = []
        with open(self.report_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        table_started = False
        for line in lines:
            if "| Package |" in line:
                table_started = True
                continue
            if not table_started or "|---|" in line:
                continue

            parts = [p.strip() for p in line.split('|') if p.strip()]
            if len(parts) >= 4:
                package, _, old_version, fixed_in_version = parts[0], parts[1], parts[2], parts[3]
                if fixed_in_version.lower() != 'na':
                    vulnerabilities.append({
                        "package": package,
                        "old_version": old_version,
                        "fixed_in_version": fixed_in_version
                    })
        print(f"INFO: Found {len(vulnerabilities)} vulnerabilities with available fixes in the report.")
        return vulnerabilities

    def generate_rewrite_recipe(self, vulnerabilities):
        """
        Generates a prompt and uses the LLM to create a composite OpenRewrite recipe.
        """
        if not vulnerabilities:
            return None

        prompt_header = (
            "Create a single OpenRewrite YAML configuration file. "
            "Do not add any explanation or markdown formatting.\n"
            "The file must start with `---`.\n\n"
            "The configuration must contain ONLY an `activeRecipes` list.\n"
            "Each entry in the list must be a fully configured `org.openrewrite.maven.UpgradeDependencyVersion` recipe with the `groupId`, `artifactId`, and `newVersion` for one of the dependencies listed below.\n\n"
            "Here are the dependencies to upgrade:\n"
        )

        dependency_list_str = ""
        for i, vuln in enumerate(vulnerabilities):
            group_id, artifact_id = vuln['package'].rsplit(':', 1)
            dependency_list_str += (
                f"{i+1}. GroupID: '{group_id}', ArtifactID: '{artifact_id}', "
                f"New Version: '{vuln['fixed_in_version']}'\n"
            )

        full_prompt = prompt_header + dependency_list_str

        recipe_yaml = self._get_llm_response(full_prompt)

        # The API might still wrap the response in markdown, so we clean it up.
        if recipe_yaml and recipe_yaml.strip().startswith("```yaml"):
            recipe_yaml = recipe_yaml.strip()
            recipe_yaml = recipe_yaml.replace("```yaml\n", "").replace("\n```", "")

        return recipe_yaml

    def apply_fixes(self, recipe_yaml):
        """
        Saves the recipe and runs Maven OpenRewrite plugin to apply it.
        """
        if not recipe_yaml or "activeRecipes" not in recipe_yaml:
            print("ERROR: LLM did not return a valid OpenRewrite configuration. Aborting.", file=sys.stderr)
            print(f"Received response:\n{recipe_yaml}")
            return

        print("--- Generated OpenRewrite Recipe ---")
        print(recipe_yaml)
        print("------------------------------------")

        print(f"INFO: Saving generated recipe to '{self.recipe_path}'...")
        os.makedirs(os.path.dirname(self.recipe_path), exist_ok=True)
        with open(self.recipe_path, 'w', encoding='utf-8') as f:
            f.write(recipe_yaml)

        print("INFO: Applying OpenRewrite recipe using Maven... (This may take a while)")
        command = [
            'mvn',
            'org.openrewrite.maven:rewrite-maven-plugin:run',
            f'-Drewrite.configLocation={self.recipe_path}'
        ]

        try:
            result = subprocess.run(command, cwd=self.project_root, capture_output=True, text=True, check=True)
            print("INFO: Maven OpenRewrite plugin executed successfully.")
            # Always print stdout to see what OpenRewrite did
            print("STDOUT:\n", result.stdout)
        except FileNotFoundError:
            print("ERROR: 'mvn' command not found. Please ensure Maven is installed and in your PATH.", file=sys.stderr)
        except subprocess.CalledProcessError as e:
            print("ERROR: Maven OpenRewrite plugin failed to execute.", file=sys.stderr)
            print("STDERR:\n", e.stderr)
            print("STDOUT:\n", e.stdout)

    def run(self):
        """Orchestrates the entire vulnerability fixing process."""
        vulnerabilities = self.parse_snyk_report()
        if not vulnerabilities:
            print("INFO: No actionable vulnerabilities found in the report. Exiting.")
            return

        recipe = self.generate_rewrite_recipe(vulnerabilities)
        if recipe:
            self.apply_fixes(recipe)
        else:
            print("ERROR: Failed to generate a recipe. No fixes will be applied.", file=sys.stderr)


def main():
    """Main function to initialize and run the vulnerability fixer."""
    print("--- Automated Vulnerability Fixer ---")
    fixer = VulnerabilityFixer()
    fixer.run()
    print("\n--- Process Completed ---")

if __name__ == "__main__":
    main()
